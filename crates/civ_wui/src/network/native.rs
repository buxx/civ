use bevy::prelude::*;
use bevy_async_task::AsyncTaskRunner;
use common::network::message::{ClientToServerMessage, ServerToClientMessage};
use std::sync::mpsc::{channel, Receiver as SyncReceiver, Sender as SyncSender};

use common::{network::message::ClientToServerNetworkMessage, space::window::Resolution};
use message_io::network::Endpoint;

use super::{
    BridgeMessage, ClientToServerReceiverResource, JoinServer, ServerToClientSenderResource,
};

use crate::network::InternalBridgeMessage;
use crate::state::ClientResource;

use message_io::node;
use message_io::node::NodeHandler;
use message_io::{
    network::{NetEvent, Transport},
    node::NodeEvent,
};
use std::sync::{Arc, Mutex};
use std::thread;

enum Signal {
    Connected,
    Disconnected,
    ClientToServerMessageAvailable,
}

pub fn react_join_server(
    trigger: Trigger<JoinServer>,
    mut _task_runner: AsyncTaskRunner<'_, ()>,
    client: Res<ClientResource>,
    to_server_receiver: Res<ClientToServerReceiverResource>,
    from_server_sender: Res<ServerToClientSenderResource>,
) {
    let config = trigger.event().0.clone();
    let handler: Arc<Mutex<Option<NodeHandler<Signal>>>> = Arc::new(Mutex::new(None));
    let server: Arc<Mutex<Option<Endpoint>>> = Arc::new(Mutex::new(None));

    let handler_ = handler.clone();
    let server_ = server.clone();
    let from_server_sender_ = from_server_sender.0.clone();
    let (bridge_sender, bridge_receiver): (
        SyncSender<ClientToServerMessage>,
        SyncReceiver<ClientToServerMessage>,
    ) = channel();
    let client_ = client.0;
    thread::spawn(move || {
        let (handler, listener) = node::split();

        let (server, _) = handler
            .network()
            .connect(Transport::FramedTcp, config.server_address.to_string())
            .unwrap();

        *handler_.lock().unwrap() = Some(handler.clone());
        *server_.lock().unwrap() = Some(server);

        listener.for_each(move |event| match event {
            NodeEvent::Network(net_event) => match net_event {
                NetEvent::Connected(_endpoint, _ok) => handler.signals().send(Signal::Connected),
                NetEvent::Accepted(_, _) => unreachable!(), // Only generated by listening
                NetEvent::Message(_endpoint, data) => {
                    let message: ServerToClientMessage = bincode::deserialize(data).unwrap();
                    from_server_sender_
                        .send_blocking(BridgeMessage::Server(message))
                        .unwrap();
                }
                NetEvent::Disconnected(_endpoint) => {
                    //
                    handler.signals().send(Signal::Disconnected)
                }
            },
            NodeEvent::Signal(signal) => match signal {
                Signal::Connected => {
                    info!("Connected");
                    from_server_sender_
                        .send_blocking(BridgeMessage::Internal(
                            InternalBridgeMessage::ConnectionEstablished(
                                config.server_address.clone(),
                            ),
                        ))
                        .unwrap();
                }
                Signal::Disconnected => {
                    info!("Disconnected")
                }
                Signal::ClientToServerMessageAvailable => {
                    if let Ok(message) = bridge_receiver.try_recv() {
                        let message = bincode::serialize(&message).unwrap();
                        handler.network().send(server, &message);
                    }
                }
            },
        });
    });

    let to_server_receiver_ = to_server_receiver.0.clone();
    thread::spawn(move || {
        while let Ok(message) = to_server_receiver_.recv_blocking() {
            let handler = handler.lock().unwrap();
            let handler = handler.as_ref().unwrap();
            bridge_sender.send(message).unwrap();
            handler
                .signals()
                .send(Signal::ClientToServerMessageAvailable);
        }
    });
}
