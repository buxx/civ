use bevy::prelude::*;
use bevy_async_task::AsyncTaskRunner;
use common::network::message::{ClientToServerMessage, ServerToClientMessage};
use std::sync::mpsc::{channel, Receiver as SyncReceiver, Sender as SyncSender};

use common::{network::message::ClientToServerNetworkMessage, space::window::Resolution};
use message_io::network::Endpoint;

use super::{ClientToServerReceiverResource, NetworkConfigResource, ServerToClientSenderResource};

use crate::state::Client;

use message_io::node;
use message_io::node::NodeHandler;
use message_io::{
    network::{NetEvent, Transport},
    node::NodeEvent,
};
use std::sync::{Arc, Mutex};
use std::thread;

enum Signal {
    Connected,
    Disconnected,
    ClientToServerMessageAvailable,
}

pub fn setup_network(
    mut _task_runner: AsyncTaskRunner<'_, ()>,
    client: Res<Client>,
    network_config: Res<NetworkConfigResource>,
    to_server_receiver: Res<ClientToServerReceiverResource>,
    from_server_sender: Res<ServerToClientSenderResource>,
) {
    let handler: Arc<Mutex<Option<NodeHandler<Signal>>>> = Arc::new(Mutex::new(None));
    let server: Arc<Mutex<Option<Endpoint>>> = Arc::new(Mutex::new(None));

    let handler_ = handler.clone();
    let server_ = server.clone();
    let from_server_sender_ = from_server_sender.0.clone();
    let server_address = format!(
        "{}:{}",
        network_config.server_host, network_config.server_port
    );
    let (bridge_sender, bridge_receiver): (
        SyncSender<ClientToServerMessage>,
        SyncReceiver<ClientToServerMessage>,
    ) = channel();
    let client_ = client.0;
    thread::spawn(move || {
        let (handler, listener) = node::split();

        let (server, _) = handler
            .network()
            .connect(Transport::FramedTcp, server_address)
            .unwrap();

        *handler_.lock().unwrap() = Some(handler.clone());
        *server_.lock().unwrap() = Some(server);

        listener.for_each(move |event| match event {
            NodeEvent::Network(net_event) => match net_event {
                NetEvent::Connected(_endpoint, _ok) => {
                    //
                    handler.signals().send(Signal::Connected)
                }
                NetEvent::Accepted(_, _) => unreachable!(), // Only generated by listening
                NetEvent::Message(_endpoint, data) => {
                    let message: ServerToClientMessage = bincode::deserialize(data).unwrap();
                    from_server_sender_.send_blocking(message).unwrap();
                }
                NetEvent::Disconnected(_endpoint) => {
                    //
                    handler.signals().send(Signal::Disconnected)
                }
            },
            NodeEvent::Signal(signal) => match signal {
                Signal::Connected => {
                    info!("Connected");
                    // Inform server about our uuid
                    let message = bincode::serialize(&ClientToServerMessage::Network(
                        ClientToServerNetworkMessage::Hello(client_, Resolution::new(1, 1)),
                    ))
                    .unwrap();
                    handler.network().send(server, &message);
                }
                Signal::Disconnected => {
                    info!("Disconnected")
                }
                Signal::ClientToServerMessageAvailable => {
                    if let Ok(message) = bridge_receiver.try_recv() {
                        let message = bincode::serialize(&message).unwrap();
                        handler.network().send(server, &message);
                    }
                }
            },
        });
    });

    let to_server_receiver_ = to_server_receiver.0.clone();
    thread::spawn(move || {
        while let Ok(message) = to_server_receiver_.recv_blocking() {
            let handler = handler.lock().unwrap();
            let handler = handler.as_ref().unwrap();
            bridge_sender.send(message).unwrap();
            handler
                .signals()
                .send(Signal::ClientToServerMessageAvailable);
        }
    });
}
